{
  "hash": "05a3ac11ac263168a27c3a05daea6cba",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Lecture 4: $k$-nearest neighbours and SVM RBFs'\ndescription: Supervised Machine Learning Fundamentals\ndescription-short: 'introduction to KNNs, hyperparameter `n_neighbours` or $k$, `C` and `gamma` hyperparameters of SVM RBF, decision boundaries with different values of hyperparameters.'\nformat:\n  revealjs:\n    embed-resources: true\n    slide-number: true\n    smaller: true\n    center: true\n    logo: img/UBC-CS-logo.png\n    resources:\n      - data/\n      - img/  \n---\n\n\n## Announcements \n\n- hw2 was due yesterday.\n- Syllabus quiz due date is September 19th, 11:59 pm. \n- Homework 3 (hw3) has been released (Due: Oct 1st, 11:59 pm)\n  - You can work in pairs for this assignment. \n- If you were on the waitlist, you should now know your course enrollment status. Registration for tutorials is not mandatory; they are optional and will follow an office-hour format. You are free to attend any tutorial session of your choice.\n- The lecture notes within these notebooks align with the content presented in the videos. Even though we do not cover all the content from these notebooks during lectures, it’s your responsibility to go through them on your own.\n\n\n## Recap\n\nWhich of the following scenarios do **NOT necessarily imply overfitting**? \n\n- (A) Training accuracy is 0.98 while validation accuracy is 0.60.\n- (B) The model is too specific to the training data. \n- (C) The decision boundary of a classifier is wiggly and highly irregular.\n- (D) Training and validation accuracies are both approximately 0.88. \n\n## Recap\n\nWhich of the following statements about **overfitting** is true? \n\n- (A) Overfitting is always beneficial for model performance on unseen data.\n- (B) Some degree of overfitting is common in most real-world problems. \n- (C) Overfitting ensures the model will perform well in real-world scenarios.\n- (D) Overfitting occurs when the model learns the training data too closely, including its noise and outliers.   \n\n\n## Recap\n\nHow might one address the issue of **underfitting** in a machine learning model. \n\n- (A) Introduce more noise to the training data. \n- (B) Remove features that might be relevant to the prediction. \n- (C) Increase the model's complexity, possibly by adding more parameter or features\n- (D) Use a smaller dataset for training. \n\n## Overfitting and underfitting \n\n- An **overfit model** matches the training set so closely that it fails to make correct predictions on new unseen data.  \n- An **underfit model** is too simple and does not even make good predictions on the training data \n\n![](img/underfit-overfit-google-developer.png){fig-align=\"center\"}\n\n[Source](https://developers.google.com/machine-learning/crash-course/overfitting/overfitting)\n\n\n## Recap \n- Why do we split the data? What are train/valid/test splits? \n- What are the benefits of cross-validation?\n- What’s the fundamental trade-off in supervised machine learning?\n- What is the golden rule of machine learning?\n\n\n## Cross validation\n\n![](img/cross-validation.png){fig-align=\"center\"}\n\n## Cross validation\n\n::: {#2f3f4759 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](slides-04-kNNs-SVM-RBF_files/figure-revealjs/cell-2-output-1.png){width=1161 height=228}\n:::\n:::\n\n\n## Summary of train, validation, test, and deployment data \n\n|         | `fit` | `score` | `predict` |\n|----------|-------|---------|-----------|\n| Train    | ✔️      | ✔️      | ✔️         |\n| Validation |      | ✔️      | ✔️         |\n| Test    |       |  once   | once         |\n| Deployment    |       |       | ✔️         |\n\n## Recap: The fundamental tradeoff\n\nAs you increase the model complexity, training score tends to go up and the gap between train and validation scores tends to go up.  \n\n![](img/malp_0201.png){fig-align=\"center\"}\n\n\n## iClicker 4.1\n\n**iClicker cloud join link: https://join.iclicker.com/VYFJ**\n\n**Select all of the following statements which are TRUE.**\n\n- (A) Analogy-based models find examples from the test set that are most similar to the query example we are predicting.\n- (B) Euclidean distance will always have a non-negative value.\n- (C) With $k$-NN, setting the hyperparameter $k$ to larger values typically reduces training error. \n- (D) Similar to decision trees, $k$-NNs finds a small set of good features.\n- (E) In $k$-NN, with $k > 1$, the classification of the closest neighbour to the test example always contributes the most to the prediction.\n\n## iClicker 4.2\nClicker cloud join link: **https://join.iclicker.com/VYFJ**\n\n**Select all of the following statements which are TRUE.**\n\n- (A) $k$-NN may perform poorly in high-dimensional space (say, *d* > 1000). \n- (B) In sklearn’s SVC classifier, large values of `gamma` tend to result in higher training score but probably lower validation score. \n- (C) If we increase both `gamma` and `C`, we can't be certain if the model becomes more complex or less complex.\n\n\n## Similarity-based algorithms \n- Use similarity or distance metrics to predict targets.\n- Examples: $k$-nearest neighbors, Support Vector Machines (SVMs) with RBF Kernel.\n\n## $k$-nearest neighbours\n- Classifies an object based on the majority label among its $k$ closest neighbors. \n- Main hyperparameter: $k$ or `n_neighbors` in `sklearn`\n- Distance Metrics: Euclidean\n- Strengths: simple and intuitive, can learn complex decision boundaries\n- Challenges: Sensitive to the choice of distance metric and **scaling** (coming up).\n\n## Curse of dimensionality \n- As dimensionality increases, the volume of the space increases exponentially, making the data sparse.\n- Distance metrics lose meaning\n    - Accidental similarity swamps out meaningful similarity\n    - All points become almost equidistant.\n- Overfitting becomes likely: Harder to generalize with high-dimensional data.\n- How to deal with this? \n    - Dimensionality reduction (PCA) (not covered in this course)\n    - Feature selection techniques.\n\n## SVMs with RBF kernel \n- RBF Kernel: Radial Basis Function, a way to transform data into higher dimensions implicitly.\n- Strengths \n    - Effective in high-dimensional and sparse data\n    - Good performance on non-linear problems.\n- Hyperparameters:\n    - C$: Regularization parameter (trade-off between correct classification of training examples and maximization of the decision margin).\n\t- $\\gamma$: Defines how far the influence of a single training example reaches.\n\n## Intuition of `C` and `gamma` in SVM RBF\n- `C` (Regularization): Controls the trade-off between perfect training accuracy and having a simpler decision boundary. \n    - High C: Strict, complex boundary (overfitting risk).\n    - Low C: More errors allowed, smoother boundary (generalizes better).\n- `Gamma` (Kernel Width): Controls the influence of individual data points.\n\t- High Gamma: Points have local impact, complex boundary.\n\t- Low Gamma: Points affect broader areas, smoother boundary.\n- Key trade-off: Proper balance between `C` and `gamma` is crucial for avoiding overfitting or underfitting.\n\n\n# [Class demo](https://github.com/UBC-CS/cpsc330-2024W1/blob/main/lectures/102-Varada-lectures/class_demos/demo_04-kNNs-SVMs.ipynb)\n\n(time permitting)\n\n",
    "supporting": [
      "slides-04-kNNs-SVM-RBF_files"
    ],
    "filters": [],
    "includes": {}
  }
}