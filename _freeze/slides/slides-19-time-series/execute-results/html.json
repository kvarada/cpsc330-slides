{
  "hash": "d6de0e66f6d945b3b23c167ed905ac36",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"CPSC 330 Lecture 19: Time series\"\nauthor: \"Varada Kolhatkar\"\nformat: \n    revealjs:\n      html-math-method: mathjax    \n      embed-resources: true\n      slide-number: true\n      center: true\n      logo: img/UBC-CS-logo.png\n      resources:\n        - data/\n        - img/        \n---\n\n\n\n## Focus on the breath!\n\n![](img/inukshuk.jpeg){.nostretch fig-align=\"center\" width=\"500px\"}\n\n## Announcements\n\n- HW8 has been released (due next week Monday)\n  - Almost there! You‚Äôve got this! üòä\n- Midterm 2 grading is in progress. \n\n## Recap: iClicker questions {.smaller}\n- (A) In multinomial logistic regression, the model learns a separate weight vector and bias for each class.\n- (B) Neural networks are powerful models, so it's usually a good idea to start with them on any new machine learning problem.\n- (C) The main reason we add hidden layers is to allow the model to learn increasingly complex representations.\n- (D) Convolutional neural networks (CNNs) use filters that slide over the image to detect local patterns.\n- (E) Using a pre-trained network as a feature extractor typically requires less data than training a deep network from scratch.\n\n## Today's lecture goals\n- What is time series? \n- How do we know a problem is a time series problem?\n- Why do standard ML models struggle with time-dependent data?\n- How can we adapt ML models to handle time series?\n\n## What type of model would be appropriate? {.smaller}\n\n| Scenario |  Model/Method |\n|-------------------------------------------------------|-------|\n| You have user‚Äìitem ratings (e.g., movie ratings) and want to predict missing ratings. | ? |\n| You have a collection of documents without any labels and want to group them into themes. | ? |\n| You want to classify the emotion of a set of text messages, but you do not have any labeled data. | ? |\n| You have a small dataset with ~500 images containing pictures and names of 20 different Computer Science faculty members from UBC. Your goal is to develop a reasonably accurate multi-class classification model for this task.| ? |\n\n## Loan default prediction (tabular data) {.smaller}\n\nYou work for a financial institution and have a dataset where each row represents a customer applying for a loan. What type of model would you use? \n\n| customer_id | income_k | credit_utilization | late_payments | employment_length | employment_type | home_ownership | loan_purpose        | default |\n|-------------|----------|--------------------|---------------|-------------------|-----------------|----------------|---------------------|---------|\n| 1           | 95       | 22                 | 0             | 9                 | salaried        | mortgage       | home_improvement    | 0       |\n| 2           | 45       | 78                 | 3             | 2                 | contract        | rent           | debt_consolidation  | 1       |\n| 3           | 120      | 30                 | 1             | 7                 | salaried        | own            | car                 | 0       |\n| 4           | 60       | 65                 | 2             | 3                 | self_employed   | rent           | debt_consolidation  | 1       |\n| 5           | 85       | 40                 | 0             | 10                | salaried        | mortgage       | education           | 0       |\n| 6           | 55       | 90                 | 4             | 1                 | contract        | rent           | debt_consolidation  | 1       |\n| 7           | 130      | 28                 | 0             | 6                 | salaried        | own            | car                 | 0       |\n| 8           | 40       | 82                 | 2             | 1                 | self_employed   | rent           | debt_consolidation  | 1       |\n\n- Rows are independent $\\rightarrow$ order does not matter $\\rightarrow$ time does not matter\n\n## citibike dataset\n\n- You have bike rental counts every three hours for one station in New York City over a month. You want to predict demand for the **next** three-hour period.  \n\n:::: {.columns}\n\n:::{.column width=\"40%\"}\n\n::: {#46463fbe .cell execution_count=2}\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nstarttime\n2015-08-01 00:00:00     3\n2015-08-01 03:00:00     0\n2015-08-01 06:00:00     9\n2015-08-01 09:00:00    41\n2015-08-01 12:00:00    39\n2015-08-01 15:00:00    27\n2015-08-01 18:00:00    12\n2015-08-01 21:00:00     4\n2015-08-02 00:00:00     3\n2015-08-02 03:00:00     4\n2015-08-02 06:00:00     6\n2015-08-02 09:00:00    30\n2015-08-02 12:00:00    46\n2015-08-02 15:00:00    27\n2015-08-02 18:00:00    28\n2015-08-02 21:00:00     6\n2015-08-03 00:00:00     3\n2015-08-03 03:00:00     2\n2015-08-03 06:00:00    21\n2015-08-03 09:00:00     9\nFreq: 3h, Name: one, dtype: int64\n```\n:::\n:::\n\n\n:::\n\n:::{.column width=\"60%\"}\n![](img/citibike.jpg)\n:::\n::::\n\n## citibike data\n\n:::: {.columns}\n\n:::{.column width=\"40%\"}\n\n::: {#21eef6b2 .cell execution_count=3}\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nstarttime\n2015-08-01 00:00:00     3\n2015-08-01 03:00:00     0\n2015-08-01 06:00:00     9\n2015-08-01 09:00:00    41\n2015-08-01 12:00:00    39\n2015-08-01 15:00:00    27\n2015-08-01 18:00:00    12\n2015-08-01 21:00:00     4\n2015-08-02 00:00:00     3\n2015-08-02 03:00:00     4\n2015-08-02 06:00:00     6\n2015-08-02 09:00:00    30\n2015-08-02 12:00:00    46\n2015-08-02 15:00:00    27\n2015-08-02 18:00:00    28\n2015-08-02 21:00:00     6\n2015-08-03 00:00:00     3\n2015-08-03 03:00:00     2\n2015-08-03 06:00:00    21\n2015-08-03 09:00:00     9\nFreq: 3h, Name: one, dtype: int64\n```\n:::\n:::\n\n\n:::\n\n:::{.column width=\"60%\"}\n- Only feature: datetime (e.g., 2015-08-01 00:00:00)\n- The data is collected at regular intervals (every three hours) \n- Target: rentals in the next 3-hour period (e.g., 9 rentals between 2015-08-01 06:00:00 and 2015-08-01 09:00:00) \n- Goal: Given past rental counts, predict the number of rentals at a specific future time.\n:::\n::::\n\n**Using only the tools in your current toolbox, what model would you choose, and what challenges might you run into?**\n\n\n\n## Why different treatement?\n\n:::: {.columns}\n\n:::{.column width=\"40%\"}\n\n::: {#7f77eb21 .cell execution_count=4}\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nstarttime\n2015-08-01 00:00:00     3\n2015-08-01 03:00:00     0\n2015-08-01 06:00:00     9\n2015-08-01 09:00:00    41\n2015-08-01 12:00:00    39\n2015-08-01 15:00:00    27\n2015-08-01 18:00:00    12\n2015-08-01 21:00:00     4\n2015-08-02 00:00:00     3\n2015-08-02 03:00:00     4\n2015-08-02 06:00:00     6\n2015-08-02 09:00:00    30\n2015-08-02 12:00:00    46\n2015-08-02 15:00:00    27\n2015-08-02 18:00:00    28\n2015-08-02 21:00:00     6\n2015-08-03 00:00:00     3\n2015-08-03 03:00:00     2\n2015-08-03 06:00:00    21\n2015-08-03 09:00:00     9\nFreq: 3h, Name: one, dtype: int64\n```\n:::\n:::\n\n\n:::\n:::{.column width=\"60%\"}\n- This type of data is distinctive because it is inherently sequential, with an intrinsic order based on time.\n- The number of bikes available at a station at one point in time is often related to the number of bikes at earlier times. \n- This is a **time-series forecasting** problem.\n:::\n::::\n\nML models do not have a built-in concept of time. We have to give it to them.\n\n## citibike data visualization\n\n::: {#c47ccd13 .cell execution_count=5}\n\n::: {.cell-output .cell-output-stdout}\n```\nStart date: 2015-08-01 00:00:00\nEnd date: 2015-08-31 21:00:00\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](slides-19-time-series_files/figure-revealjs/cell-6-output-2.png){width=963 height=528}\n:::\n:::\n\n\n- Do you see any daily patterns? Weekly patterns? Noise? \n\n## ‚õîÔ∏è Incorrect data splitting\n\n::: {#9013967c .cell execution_count=6}\n``` {.python .cell-code}\ntrain_df, test_df = train_test_split(citibike, test_size=0.2, random_state=123)\nprint('Train largest date: ', train_df.index.max())\nprint('Test smallest date: ', test_df.index.min())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrain largest date:  2015-08-31 21:00:00\nTest smallest date:  2015-08-01 12:00:00\n```\n:::\n:::\n\n\n::: {#0872696f .cell execution_count=7}\n\n::: {.cell-output .cell-output-display}\n![](slides-19-time-series_files/figure-revealjs/cell-8-output-1.png){width=793 height=346}\n:::\n:::\n\n\n‚õîÔ∏è We should never train on the future to predict the past!\n\n## ‚úÖ Correct data splitting\n\nIn time series, the simplest split is: \n\n- earlier data $\\rightarrow$ training\n- later data $\\rightarrow$ testing.\n\n::: {#531c965e .cell execution_count=8}\n``` {.python .cell-code}\nn_train = 184\ntrain_df = citibike[:184]\ntest_df = citibike[184:]\n```\n:::\n\n\n::: {#5348653f .cell execution_count=9}\n\n::: {.cell-output .cell-output-display}\n![](slides-19-time-series_files/figure-revealjs/cell-10-output-1.png){width=942 height=419}\n:::\n:::\n\n\n# Feature engineering for time series \n\n## Motivation \n\n- In this toy data, we just have a single feature: the date time feature. \n- Note that ML models do not have a built-in concept of time. We have to give it to them.\n- We will explore different ways to extract informative features from time.\n\n## POSIX time feature\n- Let's start with our worst but simplest encoding. \n- A common way that dates are stored on computers is using POSIX time, which is the number of seconds since January 1970 00:00:00 (this is beginning of Unix time). \n- Let's start with encoding feature as a single integer representing this POSIX time. \n\n::: {#984373d1 .cell execution_count=10}\n``` {.python .cell-code}\n# convert to POSIX time by dividing by 10**9\nX = (\n    citibike.index.astype(\"int64\").values.reshape(-1, 1) // 10**9\n)  # convert to POSIX time by dividing by 10**9\ny = citibike.values\nX[:10]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\narray([[1438387200],\n       [1438398000],\n       [1438408800],\n       [1438419600],\n       [1438430400],\n       [1438441200],\n       [1438452000],\n       [1438462800],\n       [1438473600],\n       [1438484400]])\n```\n:::\n:::\n\n\n## Random forest on posix features \n\n::: {#03c588c8 .cell execution_count=11}\n``` {.python .cell-code}\nregressor = RandomForestRegressor(n_estimators=100, random_state=0)\neval_on_features(X, y, regressor, xticks, feat_names=\"POSIX time\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrain-set R^2: 0.85\nTest-set R^2: -0.04\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](slides-19-time-series_files/figure-revealjs/cell-12-output-2.png){width=1001 height=403}\n:::\n:::\n\n\n- The predictions on the training data and training score are pretty good \n- But for the test data, a constant line is predicted ...\n- What's going on?\n\n## Trees cannot extrapolate! {.smaller}\n- Tree-based models (Decision Trees, Random Forests, Gradient Boosted Trees) only make predictions within the range of values they've seen during training.\n- They are excellent interpolators but terrible extrapolators because \n  - Trees partition the feature space into fixed regions and predictions inside each region are averages of training labels.\n  - If your future timestamps are larger than the ones in the training set trees cannot \"see beyond\" the training range and they will flatline or behave unpredictably.\n\nThis is exactly what happens with POSIX time encoded as a single numeric feature! \n\n\n## Extracting date and time information\n\n- Note that our index is of this special type: [`DateTimeIndex`](https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html). We can extract all kinds of interesting information from it.   \n\n::: {#a9a681a5 .cell execution_count=12}\n``` {.python .cell-code}\nprint(citibike.index[0])\nprint(citibike.index[0].month_name())\nprint(citibike.index[0].dayofweek)\nprint(citibike.index[0].hour)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2015-08-01 00:00:00\nAugust\n5\n0\n```\n:::\n:::\n\n\n## \n- We noted before that the time of the day and day of the week seem quite important. \n- Let's start with these two features. \n\n::: {#206f0004 .cell execution_count=13}\n``` {.python .cell-code}\nX_hour = citibike.index.hour.values.reshape(-1, 1)\nX_hour[:10]\nregressor = RandomForestRegressor(n_estimators=100, random_state=0)\neval_on_features(X_hour, y, regressor, xticks, feat_names=\"Hour of the day\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrain-set R^2: 0.50\nTest-set R^2: 0.60\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](slides-19-time-series_files/figure-revealjs/cell-14-output-2.png){width=1001 height=403}\n:::\n:::\n\n\nThe scores are better when we add time of the day feature! \n\n# [Class demo](https://github.com/UBC-CS/cpsc330-2024W1/blob/main/lectures/102-Varada-lectures/class_demos/demo_20_time-series.ipynb) \n\n",
    "supporting": [
      "slides-19-time-series_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}