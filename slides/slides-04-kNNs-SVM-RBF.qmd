---
title: 'Lecture 4: $k$-nearest neighbours and SVM RBFs'
author: "Varada Kolhatkar"
description: Supervised Machine Learning Fundamentals
description-short: 'introduction to KNNs, hyperparameter `n_neighbours` or $k$, `C` and `gamma` hyperparameters of SVM RBF, decision boundaries with different values of hyperparameters.'
format:
  revealjs:
    html-math-method: mathjax
    embed-resources: true
    slide-number: true
    smaller: true
    center: true
    logo: img/UBC-CS-logo.png
    resources:
      - data/
      - img/  
---

## Announcements 

- hw2 is due tonight.
- Syllabus quiz due date is September 19th, 11:59 pm. 
- Homework 3 (hw3) has been released (Due: Sept 29th, 11:59 pm)
  - You can work in pairs for this assignment. 
- If you were on the waitlist, you should now know your course enrollment status. 
- The [lecture notes here](https://ubc-cs.github.io/cpsc330-2025W1/lectures/notes/01_intro.html) align with the content presented in the videos. Even though we do not cover all the content from these notebooks during lectures, it's your responsibility to go through them on your own.


## Recap: iClicker overfitting 1

Which of the following scenarios do **NOT necessarily imply overfitting**? 

- (A) Training accuracy is very high (0.98) while validation accuracy is much lower (0.60).
- (B) In a wildlife classifier, the model predicts "wolf" whenever there"s snow in the background, because all wolf photos were taken in snowy regions.
- (C) The decision boundary of a classifier is wiggly and highly irregular.
- (D) Training and validation accuracies are both approximately 0.88. 
- (E) A cancer detection model learns that "a ruler in the corner of the X-ray" means positive, because doctors tended to measure suspicious cases.

## Recap: iClicker overfitting 2

Which of the following statements about **overfitting** is true? 

- (A) Overfitting makes the model more accurate on both training and unseen data.
- (B) Overfitting means the model captures noise or irrelevant details from the training data.
- (C) Overfitting is desirable because it reduces both training and test error.
- (D) In real-world problems, models are always at risk of overfitting if not properly validated.

## Recap: iClicker underfitting

How might one address the issue of **underfitting** in a machine learning model. 

- (A) Introduce more noise to the training data. 
- (B) Remove features that might be relevant to the prediction. 
- (C) Increase the model's complexity (e.g., more parameters, features, or deeper trees)
- (D) Use a smaller dataset for training. 

## The fundamental tradeoff {.smaller}

:::: {.columns}

::: {.column width="60%"}
![](img/malp_0201.png){fig-align="center"}
:::

::: {.column width="40%"}
- As you increase the model complexity, training score tends to go up and the gap between train and validation scores tends to go up.  
- How to pick a model? 
:::
::::

## iClicker 4.1

**Select all of the following statements which are TRUE.**

- (A) Analogy-based models find examples from the test set that are most similar to the query example we are predicting.
- (B) Euclidean distance will always have a non-negative value.
- (C) With $k$-NN, setting the hyperparameter $k$ to larger values typically reduces training error. 
- (D) Similar to decision trees, $k$-NNs finds a small set of good features.
- (E) In $k$-NN, with $k > 1$, the classification of the closest neighbour to the test example always contributes the most to the prediction.

## iClicker 4.2

**Select all of the following statements which are TRUE.**

- (A) $k$-NN may perform poorly in high-dimensional space (say, *d* > 1000). 
- (B) In sklearnâ€™s SVC classifier, large values of `gamma` tend to result in higher training score but probably lower validation score. 
- (C) If we increase both `gamma` and `C`, we can't be certain if the model becomes more complex or less complex.


## Similarity-based algorithms 
- Use similarity or distance metrics to predict targets.
- Examples: $k$-nearest neighbors, Support Vector Machines (SVMs) with RBF Kernel.

## $k$-nearest neighbours
- Classifies an object based on the majority label among its $k$ closest neighbors. 
- Main hyperparameter: $k$ or `n_neighbors` in `sklearn`
- Distance Metrics: Euclidean
- Strengths: simple and intuitive, can learn complex decision boundaries
- Challenges: Sensitive to the choice of distance metric and **scaling** (coming up).

## Curse of dimensionality 
- As dimensionality increases, the volume of the space increases exponentially, making the data sparse.
- Distance metrics lose meaning
    - Accidental similarity swamps out meaningful similarity
    - All points become almost equidistant.
- Overfitting becomes likely: Harder to generalize with high-dimensional data.
- How to deal with this? 
    - Dimensionality reduction (PCA) (not covered in this course)
    - Feature selection techniques.

## SVMs with RBF kernel 
- RBF Kernel: Radial Basis Function, a way to transform data into higher dimensions implicitly.
- Strengths 
    - Effective in high-dimensional and sparse data
    - Good performance on non-linear problems.
- Hyperparameters:
    - $C$: Regularization parameter (trade-off between correct classification of training examples and maximization of the decision margin).
	- gamma ($\gamma$): controls how fast the similarity decays with distance

## Intuition of `C` and `gamma` in SVM RBF
- `C` (Regularization): Controls the trade-off between perfect training accuracy and having a simpler decision boundary. 
    - High C: Strict, complex boundary (overfitting risk).
    - Low C: More errors allowed, smoother boundary (generalizes better).
- `Gamma` (Kernel Width): Controls the influence of individual data points.
	- High Gamma: Points have local impact, complex boundary.
	- Low Gamma: Points affect broader areas, smoother boundary.
- Key trade-off: Proper balance between `C` and `gamma` is crucial for avoiding overfitting or underfitting.


# [Class demo](https://github.com/UBC-CS/cpsc330-2024W1/blob/main/lectures/102-Varada-lectures/class_demos/demo_04-kNNs-SVMs.ipynb)

# Models
## Supervised models we have seen 

- Decision trees: Split data into subsets based on feature values to create decision rules 
- $k$-NNs: Classify based on the majority vote from $k$ nearest neighbors
- SVM RBFs: Create a boundary using an RBF kernel to separate classes

## Comparison of models (activity)
| **Model**        | Parameters and hyperparameters | **Strengths**  | **Weaknesses**     |
|------------------|--------------------------------|---------------------------|---------------------------|
| **Decision Trees**               |  |  |  |
| **KNNs**              |  |  |  |
| **SVM RBF**            |  |  |  |

