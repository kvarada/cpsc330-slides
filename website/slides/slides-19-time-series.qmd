---
title: "CPSC 330 Lecture 19: Time series"
author: "Varada Kolhatkar"
format: 
    revealjs:
      html-math-method: mathjax    
      embed-resources: true
      slide-number: true
      logo: img/UBC-CS-logo.png
      resources:
        - data/
        - img/        
---

```{python}
import matplotlib.pyplot as plt
import os, sys
import numpy as np
import pandas as pd
sys.path.append(os.path.join(os.path.abspath("."), "code"))
from time_series_code import *
from sklearn.compose import ColumnTransformer, make_column_transformer
from sklearn.dummy import DummyClassifier
from sklearn.ensemble import RandomForestRegressor
from sklearn.impute import SimpleImputer
from sklearn.linear_model import LogisticRegression, Ridge

from sklearn.model_selection import (
    TimeSeriesSplit,
    cross_val_score,
    cross_validate,
    train_test_split,
)
from sklearn.pipeline import Pipeline, make_pipeline
from sklearn.preprocessing import OneHotEncoder, OrdinalEncoder, StandardScaler

from datetime import datetime
```

## Focus on the breath!

![](img/inukshuk.jpeg){.nostretch fig-align="center" width="500px"}

## Announcements

- HW8 has been released (due next week Monday)
  - Almost there! You‚Äôve got this! üòä
- Midterm 2 grading is in progress. 

## Recap: iClicker questions {.smaller}
- (A) In multinomial logistic regression, the model learns a separate weight vector and bias for each class.
- (B) Neural networks are powerful models, so it's usually a good idea to start with them on any new machine learning problem.
- (C) The main reason we add hidden layers is to allow the model to learn increasingly complex representations.
- (D) Convolutional neural networks (CNNs) use filters that slide over the image to detect local patterns.
- (E) Using a pre-trained network as a feature extractor typically requires less data than training a deep network from scratch.

## Today's lecture goals
- What is time series? 
- How do we know a problem is a time series problem?
- Why do standard ML models struggle with time-dependent data?
- How can we adapt ML models to handle time series?

## What type of model would be appropriate? {.smaller}

| Scenario |  Model/Method |
|-------------------------------------------------------|-------|
| You have user‚Äìitem ratings (e.g., movie ratings) and want to predict missing ratings. | ? |
| You have a collection of documents without any labels and want to group them into themes. | ? |
| You want to classify the emotion of a set of text messages, but you do not have any labeled data. | ? |
| You have a small dataset with ~500 images containing pictures and names of 20 different Computer Science faculty members from UBC. Your goal is to develop a reasonably accurate multi-class classification model for this task.| ? |

## Loan default prediction (tabular data) {.scrollable}

You work for a financial institution and have a dataset where each row represents a customer applying for a loan. What type of model would you use? 

| customer_id | income_k | credit_utilization | late_payments | employment_length | employment_type | home_ownership | loan_purpose        | default |
|----|---|---|---|---|---|---|---|---|
| 1           | 95       | 22                 | 0             | 9                 | salaried        | mortgage       | home_improvement    | 0       |
| 2           | 45       | 78                 | 3             | 2                 | contract        | rent           | debt_consolidation  | 1       |
| 3           | 120      | 30                 | 1             | 7                 | salaried        | own            | car                 | 0       |
| 4           | 60       | 65                 | 2             | 3                 | self_employed   | rent           | debt_consolidation  | 1       |
| 5           | 85       | 40                 | 0             | 10                | salaried        | mortgage       | education           | 0       |
| 6           | 55       | 90                 | 4             | 1                 | contract        | rent           | debt_consolidation  | 1       |
| 7           | 130      | 28                 | 0             | 6                 | salaried        | own            | car                 | 0       |
| 8           | 40       | 82                 | 2             | 1                 | self_employed   | rent           | debt_consolidation  | 1       |

- Rows are independent $\rightarrow$ order does not matter $\rightarrow$ time does not matter

## citibike dataset

You have bike rental counts every three hours for one station in New York City over a month. You want to predict demand for the **next** three-hour period.  

:::: {.columns}

:::{.column width="40%"}
```{python}
import mglearn

citibike = mglearn.datasets.load_citibike()
citibike.head(20)
```
:::

:::{.column width="60%"}
![](img/citibike.jpg)
:::
::::

## citibike data {.smaller}

:::: {.columns}

:::{.column width="40%"}
```{python}
import mglearn

citibike = mglearn.datasets.load_citibike()
citibike.head(20)
```
:::

:::{.column width="60%"}
- Only feature: datetime (e.g., 2015-08-01 00:00:00)
- The data is collected at regular intervals (every three hours) 
- Target: rentals in the next 3-hour period (e.g., 9 rentals between 2015-08-01 06:00:00 and 2015-08-01 09:00:00) 
- Goal: Given past rental counts, predict the number of rentals at a specific future time.
:::
::::

**Using only the tools in your current toolbox, what model would you choose, and what challenges might you run into?**

## Why different treatement?

:::: {.columns}

:::{.column width="40%"}
```{python}
import mglearn

citibike = mglearn.datasets.load_citibike()
citibike.head(20)
```
:::
:::{.column width="60%"}
- This type of data is distinctive because it is inherently sequential, with an intrinsic order based on time.
- The number of bikes available at a station at one point in time is often related to the number of bikes at earlier times. 
- This is a **time-series forecasting** problem.
:::
::::

## Models for time series

The ML models we've used so far **do not have a built-in concept of time**. There are **two broad strategies** for modeling time series:

- Use models designed for sequential data which explicitly capture temporal dependencies (e.g., Hidden Markov Models, Transformer architectures etc.) 
- Use tabular ML models with engineered temporal features (e.g., Linear models, Random Forests, Gradient Boosted Trees)    

## citibike data visualization

```{python}
print("Start date:", citibike.index.min())
print("End date:", citibike.index.max())

plt.figure(figsize=(12, 5))
xticks = pd.date_range(start=citibike.index.min(), end=citibike.index.max(), freq="D")
plt.xticks(xticks, xticks.strftime("%a %m-%d"), rotation=90, ha="left")
plt.plot(citibike, linewidth=1)
plt.xlabel("Date")
plt.ylabel("Rentals");
plt.title("Number of bike rentals over time for a selected bike station");
```

- Do you see any daily patterns? Weekly patterns? Noise? 

## ‚õîÔ∏è Incorrect data splitting

```{python}
#| echo: true
train_df, test_df = train_test_split(citibike, test_size=0.2, random_state=123)
print('Train largest date: ', train_df.index.max())
print('Test smallest date: ', test_df.index.min())
```
```{python}
plt.figure(figsize=(10, 3))
train_df_sort = train_df.sort_index()
test_df_sort = test_df.sort_index()

plt.plot(train_df_sort, "b", label="train")
plt.plot(test_df_sort, "r", label="test")
plt.xticks(rotation="vertical")
plt.legend();
```

‚õîÔ∏è We should never train on the future to predict the past!

## ‚úÖ Correct data splitting

In time series, the simplest split is: 

- earlier data $\rightarrow$ training and later data $\rightarrow$ testing

```{python}
#| echo: true
# Example split
n_train = 184
train_df = citibike[:184]
test_df = citibike[184:]
```
```{python}

plt.figure(figsize=(12, 4))
train_df_sort = train_df.sort_index()
test_df_sort = test_df.sort_index()

plt.plot(train_df_sort, "b", label="train")
plt.plot(test_df_sort, "r", label="test")
plt.xticks(rotation="vertical")
plt.legend();
```
# Feature engineering for time series 

## Motivation 

- In this toy data, we just have a single feature: the date time feature. 
- Note that ML models do not have a built-in concept of time. We have to give it to them.
- We will explore different ways to extract informative features from time.

## POSIX time feature
- Let's start with our worst but simplest encoding. 
- A common way that dates are stored on computers is using POSIX time, which is the number of seconds since January 1970 00:00:00 (this is beginning of Unix time). 
- Let's start with encoding feature as a single integer representing this POSIX time. 

```{python}
#| echo: true
# convert to POSIX time by dividing by 10**9
X = (
    citibike.index.astype("int64").values.reshape(-1, 1) // 10**9
)  # convert to POSIX time by dividing by 10**9
y = citibike.values
X[:10]
```

## Random forest on posix features 


```{python}
#| echo: true
regressor = RandomForestRegressor(n_estimators=100, random_state=0)
eval_on_features(X, y, regressor, xticks, feat_names="POSIX time")
```

- The predictions on the training data and training score are pretty good 
- But for the test data, a constant line is predicted ...
- What's going on?

## Trees cannot extrapolate! {.smaller}
- Tree-based models (Decision Trees, Random Forests, Gradient Boosted Trees) only make predictions within the range of values they've seen during training.
- They are excellent interpolators but terrible extrapolators because 
  - Trees partition the feature space into fixed regions and predictions inside each region are averages of training labels.
  - If your future timestamps are larger than the ones in the training set trees cannot "see beyond" the training range and they will flatline or behave unpredictably.

This is exactly what happens with POSIX time encoded as a single numeric feature! 


## Extracting date and time information

- Note that our index is of this special type: [`DateTimeIndex`](https://pandas.pydata.org/docs/reference/api/pandas.DatetimeIndex.html). We can extract all kinds of interesting information from it.   

```{python}
#| echo: true
print(citibike.index[0])
print(citibike.index[0].month_name())
print(citibike.index[0].dayofweek)
print(citibike.index[0].hour)
```

## Time of the day 
- We noted before that the time of the day and day of the week seem quite important. 
- Let's start with time of the day. 

```{python}
#| echo: true
X_hour = citibike.index.hour.values.reshape(-1, 1)
X_hour[:10]
```

## Random forest with time of the day

```{python}
#| echo: true
regressor = RandomForestRegressor(n_estimators=100, random_state=0)
eval_on_features(X_hour, y, regressor, xticks, feat_names="Hour of the day")
```

The scores are better when we add time of the day feature! 

## Time of the day + Day of the week 
Now let's add day of the week along with time of the day. 
```{python}
#| echo: true
X_hour_week = np.hstack(
    [
        citibike.index.dayofweek.values.reshape(-1, 1),
        citibike.index.hour.values.reshape(-1, 1),
    ]
)
X_hour_week
```
## Random forest with Time of the day + Day of the week 
```{python}
#| echo: true
eval_on_features(X_hour_week, y, regressor, xticks, feat_names = "hour of day + day of week")
```

The time of the day and day of the week features are clearly helping. 

## Linear model 
Let's try an interpretable linear model `Ridge` with these features. 

```{python}
lr = Ridge();
eval_on_features(X_hour_week, y, lr, xticks, feat_names = "hour of day + day of week")

```
- Why is `Ridge` performing poorly on the training data as well as test data?

## Encoding time and day with OHE 

```{python}
#| echo: true
enc = OneHotEncoder()
X_hour_week_onehot = enc.fit_transform(X_hour_week).toarray()
hour = ["%02d:00" % i for i in range(0, 24, 3)]
day = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
features = day + hour
pd.DataFrame(X_hour_week_onehot, columns=features).head(6)
```

## Linear model with OHE day and time 
Let's try an interpretable linear model `Ridge` with these features. 

```{python}
#| echo: true 
eval_on_features(X_hour_week_onehot, y, Ridge(), xticks, feat_names="hour of day OHE + day of week OHE")
```

- The scores are a bit better! 
- Can we improve them further? 


## Add interaction features 
```{python }
from sklearn.preprocessing import PolynomialFeatures

poly_transformer = PolynomialFeatures(
    interaction_only=True, include_bias=False
)
X_hour_week_onehot_poly = poly_transformer.fit_transform(X_hour_week_onehot)
hour = ["%02d:00" % i for i in range(0, 24, 3)]
day = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
features = day + hour
features_poly = poly_transformer.get_feature_names_out(features)
df_hour_week_ohe_poly = pd.DataFrame(X_hour_week_onehot_poly, columns = features_poly)
df_hour_week_ohe_poly.iloc[:, [0, 1, 2, 3, 4, 5, 34, 35, 36, 37, 40]].head(6)
```

## Linear model with OHE day and time + interaction feats
```{python}
eval_on_features(X_hour_week_onehot_poly, y, lr, xticks, feat_names = "hour of day OHE + day of week OHE + interaction feats")
```
The scores are much better now!! 

## Interpretation 

Since we are using a linear model, we can examine the coefficients learned by `Ridge`. 

```{python}
features_nonzero = np.array(features_poly)[lr.coef_ != 0]
coef_nonzero = lr.coef_[lr.coef_ != 0]
pd.DataFrame(coef_nonzero, index=features_nonzero, columns=["Coefficient"]).sort_values(
    "Coefficient", ascending=False
)
```
 
**Do these coefficients make sense?**


## Interim summary {.smaller}

- Success in time-series analysis heavily relies on the appropriate choice of models and features.
- Tree-based models cannot extrapolate; caution is needed when using them with linear integer features.
- Linear models struggle with cyclic patterns in numeric features (e.g., numerically encoded time of the day feature) because these patterns are inherently non-linear.
- Applying one-hot encoding on such features transforms cyclic temporal features into a format where their impact on the target variable can be independently and linearly modeled, enabling linear models to effectively capture and use these cyclic patterns. 

## Lag-based features

:::: {.columns}

:::{.column width="40%"}
```{python}
rentals_df = pd.DataFrame(citibike)
rentals_df = rentals_df.rename(columns={"one":"n_rentals"})
rentals_df.head(10)
```
:::

:::{.column width="60%"}
- In time series data there is temporal dependence; observations close in time tend to be correlated.
- Currently we're using current time to predict the number of bike rentals in the next three hours.
- But, what if the number of bike rentals is also related to bike rentals three hours ago or 6 hours ago and so on?
:::
:::: 

Such features are called lagged features.

## Creating lag features

```{python}
#| echo: true
def create_lag_df(df, lag, cols):
    return df.assign(
        **{f"{col}-{n}": df[col].shift(n) for n in range(1, lag + 1) for col in cols}
    )
rentals_lag5 = create_lag_df(rentals_df, 5, ['n_rentals'] )
rentals_lag5.head(8)
```

## Linear model with lag features

```{python}
X_lag_features = rentals_lag5.drop(columns = ['n_rentals']).to_numpy()
eval_on_features(X_lag_features, y, lr, xticks, feat_names="Lag features", impute="yes")
```


## Random Forest with lag features

```{python}
imp = SimpleImputer()
X_lag_features_imp = imp.fit_transform(X_lag_features)
eval_on_features(X_lag_features_imp, y, regressor, xticks, feat_names="Lag features")
```

## Random Forest with time and day + lag features
```{python}
X_hour_week_onehot_poly_lag = np.hstack([X_hour_week_onehot_poly, X_lag_features])
eval_on_features(X_hour_week_onehot_poly_lag, y, regressor, xticks, feat_names = "hour of day OHE + day of week OHE + interaction feats + Lag feats")
```

## Cross-validation with time series

- We can't do regular cross-validation if we don't want to be predicting the past.

- There is [`TimeSeriesSplit`](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.TimeSeriesSplit.html) for time series data. 

```{python}
from sklearn.model_selection import TimeSeriesSplit
# Code from sklearn documentation
X_toy = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])
y_toy = np.array([1, 2, 3, 4, 5, 6])
tscv = TimeSeriesSplit(n_splits=3)
for train, test in tscv.split(X_toy):
    print("%s %s" % (train, test))
```

# Forecasting further into the future 

## Problem
- So far, our lag features let us predict 3 hours ahead. 
- What if we want to predict 15 hours in the future? 
- Problem: We do not yet know the rental counts for the required lag timestamps:
    - 2015-09-01 00:00:00
    - 2015-09-01 03:00:00
    - 2015-09-01 06:00:00
    - 2015-09-01 09:00:00
- Without those values, our lag features break üò¢

## Approach 1: Iterative forecasting

- Train one model that predicts 3 hours ahead.
- At prediction time, move forward step by step, using your own predictions as future lag inputs.

**Example:**

- Predict rentals at 00:00 on 2015-09-01.
- Use that prediction as the lag to predict rentals at 03:00.
- Use both predictions to predict rentals at 06:00.
- Continue until you reach 12:00.

This method works, but errors accumulate as we step forward. The longer the horizon, the more uncertainty grows. 

## Approach 2: Direct forecasting (multiple horizons)

- Train separate models for each horizon:
  - Model 1 $\rightarrow$ predict 3 hours ahead
  - Model 2 $\rightarrow$ predict 6 hours ahead
  - Model 3 $\rightarrow$ predict 9 hours ahead

Each model uses lag features that match the required horizon.


## (Optional) Approach 3: Multi-output models (joint forecasting)

- Train one model that predicts several future steps at once, e.g.:

  ```y = [rentals_in_3h, rentals_in_6h, rentals_in_9h, ...]```

- These models learn relationships across future time steps.
- Note: Multi-output forecasting is powerful, but outside the scope of CPSC 330.

# Seasonality and trends 


## Trends 
Let's consider another time series dataset, [Retail Sales of Clothing and Clothing Accessory Stores dataset](https://fred.stlouisfed.org/series/MRTSSM448USN). 

```{python}
retail_df = pd.read_csv("data/MRTSSM448USN.csv", parse_dates=["DATE"])
retail_df.columns = ["date", "sales"]
retail_df.plot(x="date", y="sales", figsize=(10, 5));
```

- It looks like there's a **trend** here; the sales are going up over time. 
- How can we encode this information in the model?


## Days since feature 

One idea is to create a feature such as "Days_since"

```{python}
def lag_df(df, lag, cols):
    return df.assign(
        **{f"{col}-{n}": df[col].shift(n) for n in range(1, lag + 1) for col in cols}
    )
retail_lag_5 = lag_df(retail_df, 5, ["sales"])
retail_train_5 = retail_lag_5.query("date <= 20160101")
retail_test_5 = retail_lag_5.query("date >  20160101")
retail_train_5_date = retail_lag_5.query("date <= 20160101")
first_day_retail = retail_train_5_date["date"].min()

retail_train_5_date = retail_train_5_date.assign(
    Days_since=retail_train_5_date["date"].apply(lambda x: (x - first_day_retail).days)
)
retail_train_5_date.head(10)
```



# [Class demo](https://github.com/UBC-CS/cpsc330-2024W1/blob/main/lectures/102-Varada-lectures/class_demos/demo_20_time-series.ipynb) 

